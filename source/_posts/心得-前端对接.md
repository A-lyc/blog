---
title: 心得-前端对接
date: 2019-11-26 09:53:05
category: 前端心得
tags:
  - 经验
---

> 本文讨论：
> 需要等待后端接口才能继续开发时该如何优雅的面对

> 前排提示（不知道该把这段话放哪里...就放这里吧）
> 约定字段这件事通常只是一个规范，一个好的习惯。
> 实际情况前后端可能不会去约定，也无法准确约定，总有纰漏
> 通常情况是 “个做个的”
> 然后数据通过接口返回时才知道字段名
> 好一点的会统一定义些数据模型
> 但是特殊功能，表单提交等，通常也无法保证统一定义
> 所以，“约定字段” 本身不太靠谱
> 我更倾向定义前端字段，然后转化后端字段为前端字段的方式
> 本文也是在讨论 “前段字段”

## 开发时后端各类情况分析

1. 完美型: 已有成型接口
> 分析：非常理想的开发体验，通常为重构项目等
> 方案：该情况下可以直接使用已有接口进行前端开发，无需特殊注意
> 星级：★★★★★

2. 常规型：没有成型接口，前后端同时进行
> 分析：通常为新项目
> 方案：本文着重探讨的情况，继续往下看吧
> 星级：★★★★

3. 缺陷型：没有成型接口，后端进度比前端慢，甚至慢很多，需要等待接口
> 分析：后端项目多，任务重等场景
> 方案：本文着重探讨的情况，继续往下看吧
> 星级：★★

4. 不知所措型：没有成型接口，后端遥遥无期，甚至迷茫
> 分析：后端极度不确定
> 方案：本文着重探讨的情况，继续往下看吧
> 星级：★

## 解决方案

1. 青铜：无接口不进行
> 解释：完成基础样式后，放任项目不管，等待后端提供接口后，继续进行。
> 分析：非常适合小型无复杂功能类项目。
> 优点：劳动力最小，小项目很实用
> 缺点：中大项目不适用，开发体验不连贯，“头重，尾重，中间轻”，接口对接时需要同时兼顾前端逻辑和后端对接，导致无法专一面对问题。

2. 王者：mock 数据继续进行
> 解释：模拟一些数据，继续往下开发，有接口时，将 mock 的数据替换成真实数据
> 分析：mock 数据是 “无后端” 时的唯一办法
> 优点：开发连贯，可以在无后端的情况下，打包一份 mock 版本，保证前端任务完成
> 缺点：根据不同项目需要选择最优的 mock 方式，不健壮的 mock 会带来一定烦恼
> 不健壮的 mock 举例场景如下

- mock 数据后，无法灵活的切换 mock 环境和 “真实接口” 环境，导致项目频繁报错，查原因很麻烦。

## 何来 mock
> mock 数据的作用就是在无 “真实数据源” 的时候提供一个 “虚假数据源”
> 不影响正常流程
> 等待有 “真实数据源” 时，再尽量 ！！无缝切换！！

## 如何优雅的 mock
> ...待完成


## 来个例子
> 例子使用了 vue-cli3
> 开发步骤：

1. 定义 mock 环境
```
新建 .env.mock 文件，文件内容 VUE_APP_MOCK=true
新增 mock 相关启动命令
npm run dev        -> 开发模式，正式对接版本
npm run build      -> 产品模式，正式对接版本
npm run dev:mock   -> 开发模式，mock 版本
npm run build:mock -> 产品模式，mock 版本
```

2. 分析并定义页面需要的字段
3. 根据环境 mock 数据，完成功能(提交表单等打印出参数，确保正确)
4. 后端接口完成，正式对接(此时退出 mock 环境，进入正式对接开发环境)
5. 对接口数据进行处理，转换成 "前端字段" 后再进行赋值
6. 完成表单提交等，必须有后端才能继续的功能
```html
<template>
  <div>
    <!-- ... -->
    <div v-if="dataArr">
      <div v-for="(item, i) in dataArr" :key="i">
        {{ item.name }}
      </div>
    </div>
    <div>
      <h3>{{ id }}</h3>
      <input v-model="form.name" type="text">
      <button @click="submit">提交</button>
    </div>
    <!-- ... -->
  </div>
</template>
```
```javascript
// 是否为 mock 环境
const IS_MOCK = process.env.VUE_APP_MOCK;

export default {
  data () {
    return {
      id: IS_MOCK ? '10086' : null,
      dataArr: IS_MOCK ? [
        { name: 1, originData: null },
        { name: 2, originData: null }
      ] : null,
      // 不需要 mock 字段
      bannerI: 0,
      form: {
        name: ''
      }
    }
  },
  methods: {
    // 组件初始化方法
    async init () {
      // 正式对接
      if (!IS_MOCK) {
        // 发送请求获取数据
        let dataArr = await (axios.get('...')).data
        // 转换数据
        this.dataArr = dataArr.map(() => {/****/})
      }
    },
    // 提交表单
    submit () {
      if (IS_MOCK) {
        console.log('------------------------------')
        console.log('提交表单测试：')
        console.log(this.form);
        console.log('------------------------------')
        console.log('')
      }
      else {
        /* 正式对接 */
      }
    }
  },
  created () {
    this.init();
  }
}
```

7. 项目需求修改，从步骤 1 重新开始，无限循环

## 非技术经验
> 用 "王者" 方法还有一个优点是 "自我保护"
> 通常项目卡住时，若前端依赖后端，导致页面显示异常
> 你的团队和领导并不知道项目是卡在谁手中(耳听为虚，眼见为实)
> 客户或领导通常不懂技术
> 但肯定是看前端页面来判断项目是否完成，很显然，此时锅通常/有时就在委屈的前端这里了...
> 通过此方法，可以 mock 出一份静态版本
> 沟通时就可以对着 mock 版说 "前端部分已基本完成，等后端写接口正式对接" (后端的锅)

> 我不认为这是推责任
> 我认为这是将项目推到正确的方向
> 正视关键问题所在，正确引导解决项目问题
> 前端打死也不可能自己变出真实数据接口来呀
