---
title: 心得-前端对接
date: 2019-11-26 09:53:05
category: 前端心得
tags:
  - 经验
---

> 做项目时
> 经常有需要后端提供接口才能继续往下进行的场景
> 本文主要讨论碰到该类场景，如何优雅的处理

## 后端各类情况分析

1. 完美型: 已有成型接口
> 分析：非常理想的开发体验，通常为重构项目等
> 方案：该情况下可以直接使用已有接口进行前端开发，无需特殊注意
> 星级：★★★★★

2. 常规型：没有成型接口，前后端同时进行，约定或者没有约定数据字段
> 分析：通常为新项目
> 方案：本文着重探讨的情况，继续往下看吧
> 星级：★★★★

3. 缺陷型：没有成型接口，后端进度比前端慢，甚至慢很多，约定或者没有约定数据字段
> 分析：后端项目多，任务重等场景
> 方案：本文着重探讨的情况，继续往下看吧
> 星级：★★

4. 不知所措型：没有成型接口，后端遥遥无期，甚至迷茫
> 分析：后端极度不确定
> 方案：本文着重探讨的情况，继续往下看吧
> 星级：★

## 问题小记
> 总结起来就是没有正式接口，无法确定返回的 key 值，前端无法继续做功能
> 就算通过传统 mock 数据的方式，后期也需要大量修改 key 值代码，造成很多问题，开发体验极差
> 并且部分复杂提交表单等功能，必须依赖后端的返回值实现连贯逻辑，光靠 mock 无法继续

## 解决方案

1. 青铜：无后端不进行
> 解释：完成切图后，放任项目不管，等待后端提供接口后，继续进行。
> 分析：非常适合小型无复杂功能类项目。
> 优点：劳动力小
> 缺点：开发体验不连贯，“头重，尾更重，中间轻”，对接时需要同时兼顾前端逻辑和后端对接。

2. 白银：在前端 mock 一些假数据
> 解释：冒充后端，表单提交等场景打印出参数确保正确，正式对接时 key 值和后端商量着改
> 分析：该方案为 3 做铺垫，mock 数据是 “无后端” 场景又想继续进行的唯一办法...
> 优点：开发连贯，可以在无后端的情况下，打包一份 mock 版本
> 缺点：会有 “沟通问题” 和 “字段成型差异”，“改” 可能会 “大改” 甚至 “全改”

3. 王者：新增 mock 环境，定义前端字段，不需要与后端相同，通过 loader 转换，实现 "预卜先知"
> 解释：定义前端字段实现功能，对接时通过 "转换器" ，将后端字段转为前端字段
> 分析：用 "转换器" 的代价，避免了 "沟通成本"，避免了后端随意更改，防止了后期大改代码
> 优点：极佳的开发体验，开发连贯，随时打包一份 mock 版本。
> 缺点：需要额外增加 "转换器" 代码，作为后端字段和前端字段之间的桥梁，增大项目体积
> 注意：尽量增加 originData 字段，记录转换前的数据（方便后期维护修改，或增加其他逻辑）

## 来个例子
> 例子使用了 vue-cli3
> 开发步骤：

1. 定义 mock 环境
```
新建 .env.mock 文件，文件内容 VUE_APP_MOCK=true
新增 mock 相关启动命令
npm run dev        -> 开发模式，正式对接版本
npm run build      -> 产品模式，正式对接版本
npm run dev:mock   -> 开发模式，mock 版本
npm run build:mock -> 产品模式，mock 版本
```

2. 分析并定义页面需要的字段
3. 根据环境 mock 数据，完成功能(提交表单等打印出参数，确保正确)
4. 后端接口完成，正式对接(此时退出 mock 环境，进入正式对接开发环境)
5. 对接口数据进行处理，转换成 "前端字段" 后再进行赋值
6. 完成表单提交等，必须有后端才能继续的功能
```html
<template>
  <div>
    <!-- ... -->
    <div v-if="dataArr">
      <div v-for="(item, i) in dataArr" :key="i">
        {{ item.name }}
      </div>
    </div>
    <div>
      <h3>{{ id }}</h3>
      <input v-model="form.name" type="text">
      <button @click="submit">提交</button>
    </div>
    <!-- ... -->
  </div>
</template>
```
```javascript
// 是否为 mock 环境
const IS_MOCK = process.env.VUE_APP_MOCK;

export default {
  data () {
    return {
      id: IS_MOCK ? '10086' : null,
      dataArr: IS_MOCK ? [
        { name: 1, originData: null },
        { name: 2, originData: null }
      ] : null,
      // 不需要 mock 字段
      bannerI: 0,
      form: {
        name: ''
      }
    }
  },
  methods: {
    // 组件初始化方法
    async init () {
      // 正式对接
      if (!IS_MOCK) {
        // 发送请求获取数据
        let dataArr = await (axios.get('...')).data
        // 转换数据
        this.dataArr = dataArr.map(() => {/****/})
      }
    },
    // 提交表单
    submit () {
      if (IS_MOCK) {
        console.log('------------------------------')
        console.log('提交表单测试：')
        console.log(this.form);
        console.log('------------------------------')
        console.log('')
      }
      else {
        /* 正式对接 */
      }
    }
  },
  created () {
    this.init();
  }
}
```

7. 项目需求修改，从步骤 1 重新开始，无限循环

## 非技术经验
> 用 "王者" 方法还有一个优点是 "自我保护"
> 通常项目卡住时，若前端依赖后端，导致页面显示异常
> 你的团队和领导并不知道项目是卡在谁手中(耳听为虚，眼见为实)
> 客户或领导通常不懂技术
> 但肯定是看前端页面来判断项目是否完成，很显然，此时锅通常/有时就在委屈的前端这里了...
> 通过此方法，可以 mock 出一份静态版本
> 沟通时就可以对着 mock 版说 "前端部分已基本完成，等后端写接口正式对接" (后端的锅)

> 我不认为这是推责任
> 我认为这是将项目推到正确的方向
> 正视关键问题所在，正确引导解决项目问题
> 前端打死也不可能自己变出接口来呀
